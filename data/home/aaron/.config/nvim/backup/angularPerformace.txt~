Technology Orientation Manual
Angular Performance
	Load Time Performance
		1. AOT (Ahead of Time): As opposed to JIT Compilation where the compilation is done in the browser, AOT compiles much of the code during the build process (also called off-line compilation) thus reducing much of the processing overhead on the client browser. Use Angular-cli to specify the "aot" flag (if prod flag is present, then aot flag not required) and AOT will be enabled.
		2. Tree-shaking: Remove unused code to reduce build size. For Angular-cli, tree-Shaking is enabled by default.
		3. Uglify: Reduce code size through various code transformations like mangling, removal of white spaces, removal of comments etc. With webpack use the uglify plugin in tandem with with "prod" flag on Angular-cli to perform the uglification process.
		4. Google Closure Compiler: This is a popular compiler used by Google for their products which results in much smaller bundle size compared to Webpack uglify by performing much more aggressive minification. Even though it is not officially supported by the Angular team, this implementation is available for the closure compiler.
		5. Webpack 4: Using Webpack 4 (and higher) for angular-cli or custom webpack build results in more smaller build size compared to Webpack 3. Webpack 4 has mode option which lets you specify the optimization type (production or development) without the requirement to write any explicit configuration giving the best possible results for the target environment. Also, build time with Webpack 4 is much faster (60% to 98%) than the earlier version thereby reducing the development time.
		6. Prod flag: For the production, build specify the “prod” flag in the angular-cli application. It will enable various build optimizations like uglify, AOT, removal of sourcemaps, service workers (if enabled) producing a much smaller build size.
		7. Build-optimizer flag: When using angular-cli make sure to specify the "build-optimizer" flag for the production build. This will disable the vendor chunk and will result in more smaller code.
		8. Lazy loading: Lazy loading is the mechanism where instead of loading the complete app, only load the modules which are required at the moment thereby reducing the initial load time. In simple words, it means "don't load something which you don't need."
		9. Server side rendering: Rendering the first page of your application on the server (using Node.js, .Net) and serving it as a static page causes near to instant rendering thus greatly improves perceived performance, speed, and overall user experience. Use Angular Universal to perform server side rendering.
		10. Progressive Web App: PWA makes the app load much faster, it gives off-line capability to the app and gives near native app experience thus greatly improving overall perceived performance by the user.
		11. Ivy Render Engine: Use the new render engine called Ivy. It results in much smaller bundle size than the current engine with improved debugging experience. Though it is still not production ready it is still possible to try it on new Apps built on Angular 7.
		12. Updating Angular and angular-cli: Update Angular and angular-cli regularly to avail the benefit of many performance optimizations, bug fixes, new features, security etc.
		13. RxJS 6: RxJS 6 makes the whole library more tree-shakable thereby reducing the final bundle size. It also has some breaking changes like discouraging operator chaining instead, it encourages pipe() function (helps in better tree shaking) to add operators.
		14. Service worker cache: If the App is configured to support Progressive Web App, make sure to specify all the necessary static resources in the PWA config JSON. These static files will be cached in the client's browser making the second time load much faster.
		15. Cache-control header: cache-control header controls who caches the response under what condition and for how long thus eliminating the need for network round trip for the resources which are cached.
		16. Unnecessary use of third-party packages: If third-party packages have been included just to achieve a small functionality which could be easily done natively with JavaScript or Angular then the App will have an unnecessary size overhead. For example, if "Lodash" library is used just to do a simple object filtering then it could have been done better using native JavaScript.
		17. Defer attribute: Use "defer" attribute in script tag to defer the loading of the scripts (synchronous) until the document is completely parsed thus making the site interaction quicker. For angular-cli app currently there is no way to add this automatically during the build, it must be done manually after the build.
		18. Async attribute: Much like the defer attribute, "Async" loads external scripts asynchronously independent of the page load and executes it as soon as it's available. The best example to use it with google analytics script which is usually independent of any other scripts.
		19. Gzip compression: Gzip compression can greatly decrease the size of the response body and hence increase the speed of a web app. Make sure Gzip compression is enabled in the back-end. For express.js one can add compression middleware.
		20. Preload and Prefetch attributes: These attributes help to load the static resources as quickly as possible thus improving the time for first meaningful paint. Having faster first meaningful paint greatly affect the user experience. Preload and Prefetch are almost similar with the only difference being that Preload resources have greater priority. Use Preload for the assets which are essential for the initial rendering and use Prefetch for the resources which are required after site load (required in future across the pages).
		21. Updating Third Party Packages: Update third party packages regularly. Many times newer packages may contain many performance improvements including smaller size and other build time performance optimizations (e.g. RxJS 6). Receive improvements related to the bug fixes, security vulnerability fixes, fixes related to package compatibility etc, by regularly updating packages.
		22. Compressing images: Compress images without losing much of the quality thereby saving the bytes transferred over the network  and thus improving the build time. There are many tools available to achieve this. VS Code extension called TinyPNG can be used to compress Jpeg and PNG images without losing much of the quality.
		23. Remove unused fonts: Remove unused fonts which may help you save few bytes over the network.
		24. Slow DNS and SSL: Make sure the DNS and SSL are fast and configured correctly.

	Run Time Performance
		1. Change Detection: By default on each asynchronous event, Angular performs a dirty checking by performing a change detection for the whole component tree. Such dirty checking could be very computation heavy for medium to large Apps.  Drastically reduce the change detection by setting "Change Detection Strategy" to "OnPush". The "OnPush" strategy promotes the use of immutable data structures.
		2. Detach Change Detector: One can completely detach the component from change detection thereby giving the developer the control to inform Angular as to when and where to perform the change detection. Ex.
			import {AfterViewInit, ChangeDetectorRef} from '@angular/core';
				@Component(...)
				class AppComponent implements AfterViewInit {

				    constructor(private cdr: ChangeDetectorRef) {}
					ngAfterViewInit() {
					// We only want to detach the change detectors after change detection has been
					// performed for the first time
					this.cdr.detach();
				}

				update() {
				// Run change detection only for this component when update() method is called.
				this.cdr.detectChanges();
				}
			}
		3. Web Workers: The JavaScript implementation in all browser is single threaded thus making the whole app to run on a single thread. Such single-threaded execution drastically reduces the frame rate of the complex application as both UI painting and JS execution is handled by the same thread. As Angular by default avoids direct DOM manipulation, it is possible to run the entire Angular app in a separate web worker thread thereby keeping the main thread free to just handle the UI rendering. Consider running the angular-cli app inside a web worker. However, there are many npm packages which try to access DOM directly which may create issues while running the whole app inside the worker process. Another option is to run only a piece of code under a web worker thread. An example is the NPM angular2-web-worker package.
		4. TrackBy: By default, *ngFor identifies object uniqueness by reference. If the object reference is broken by updating the content of the object, Angular removes the related DOM node completely and will recreate it again even though the actual change required is for only a small part of the DOM node. This issue can be easily solved by using trackBy. Ex.
		@Component({
			selector: 'app',
			template: `<ul>
						<li *ngFor="let item of items; trackBy: trackById">{{item.name}}</li>
						</ul>`
		})
		class AppComponent {
			Items = [
				{
					id: 1,
					name: 'item 1'
				}, {
					id: 2,
					name: 'item 2'
				},
				...
			];
			trackById(index, item) {
				return item.id;
			}
		}
		5. Pure Pipes: Using the "@Pipe" decorator one can specify "pure" flag as true. This flag indicates that the pipe is not dependent on any outside or global state and is side effect free. This enables Angular to cache the outputs for all the input parameters the pipe has been invoked with and thus allows to reuse the values instead of re-computation. This can lead to a massive reduction in the duplicate operations performed in many cases thus hugely improving the performance.
		6. Avoid complex computations in the template: Avoid doing complex calculation in the HTML template (ex calling some component method inside the template), instead leverage the use of pure pipes thereby taking advantage of Angular caching and hence avoiding duplicate operations or if the use of pipe is not possible, see the opportunity to pre-calculate the values and then directly bind values instead of calling the component method in the template.
		7. enableProdMode: Invoking "enableProdMode()" avoids Angular from performing additional checks for change detection.
		8. AOT Compilation: AOT not only improves the build time performance but also the runtime performance of the app.
		9. Optimize Events: Slower DOM events block change detection until the event is not completed. For example, if there is a click event in the template which handled the component and the component itself is calling service method to process it, the change detection will not complete until the control is not returned from the service. If the service is taking more time to perform the intended operation, then it will ultimately slow down the change detection. Look for opportunities to optimize logic to improve the duration or if possible try to move the service logic to separate web worker thread or use wasm if needed.
		10. Unsubscribing Observables: Observables could create memory leak issue. So it is better to unsubscribe them when they are not needed any more. However, you don't have to unsubscribe all the observables used. Unsubscribing explicitly is required when a subscription is created inside a component which is destroyed before the observable completes.
		11. Observable share() operator: If you have subscribed the observable at multiple locations/components, then each subscription will try to produce the data even though the data is duplicate. We can avoid the processing of the duplicate data across subscriptions using the "share()" operator. Ex.
		import {Injectable} from '@angular/core';
		import {HttpClient} from '@angular/common/http';
		import {Observable} from 'rxjs';
		import {share} from 'rxjs/operators';
		@Injectable()
		export class AppService {
			data: Observable < any >;
			constructor(private http : HttpClient) {
				this.data = this.http.get<any> ('apiUrl').pipe(share());
			}
			getData() {
				return this.data;
			}
		}
		12. Progressive Web Apps: The PWA gives you a load time optimization as well as runtime optimizations making the app more responsive, interactive and fast with smooth animations and off-line support etc.
		13. Updating Third Party Packages: Again regularly updating your third party packages may also result in better run time performance.
		14. Console.log(): Using console.log() statements in production code could be a bad idea as it will slow down the performance of the app and also logging objects with console.log() creates memory leak issues. When browser's console window is open, the console.log() execution slows down even further by many times thus impacting site's performance significantly. It's better to completely remove the console.log() statements from production code or at least have an environment specific conditional logging.
		15. Global Variables: There are many disadvantages of using global variables and one of them is the memory leak. The variables defined in the global scope won't be cleared until the window is reloaded or tab is closed thus resulting in the memory leak if the global variable is not intended to be used throughout the app. If for some reason you want to have global variables, there are better ways to do it in Angular.
		16. Event listeners: Adding event listeners to the DOM node could create memory leak issue. If you forget to remove the listener inside the $destroy event of your directive, it will hold a reference to a DOM node even if it is removed from the document. The DOM tree will then become a "Detached DOM tree" and will leak. Modern JS engines are able to figure most of this situations and remove the listeners, but more complex tree hierarchies can challenge even the best GC.
		17. Bad Third Party Packages: Bad third party packages having performance issues (memory leak, costly js execution, security etc) can ultimately affect the app's performance. It is advisable to properly review any third party package before using it.

	RxJs Best Practices
		1. Pipeable operators: Since version 5.5 RxJS has introduced these so called pipeable operators which are easier to import than patch operators, and also have treeshaking advantages. Ex.
			// BAD: This is the old way and should be avoided (patch operators)
			// as we can see the operators (filter, map) are part of the
			// Observable prototype
			import 'rxjs/add/operator/filter';
			import 'rxjs/add/operator/map';
			const new$ = Observable.interval$
			    .filter(v => v % 2 === 0)
			    .map(v => v * 2);

			// GOOD: This is the new and improved way (lettable operators)
			// we just use the pipe operator where we pass operators that
			// we can import from 'rxjs/operators'
			import {filter, map} from 'rxjs/operators';
			const new$ = interval$
			    .pipe(
			        filter(v => v % 2 === 0),
			        map(v => v *2)
		    )
		2. ASCII marble diagrams: ASCII diagrams have more advantages then just documenting viz.
				It gives us a graphic thinking model
				It becomes easy to review someones code and validate to see if it really does what it’s supposed to be doing
					Great to draw on a whiteboard before we start coding
				You can type them in your IDE or editor before you actually start coding. (An easy way to trick your mind into thinking reactively)
				We can use them to write unit tests as well.
			The concepts behind ASCII marble documentation are quite simple. Take this easy example for instance:

			// ---a--b--c--d---e---...
			// ---a--b--c--d---e|
			// ---a--b--c--d---e#
			// ---a--b-^-c--d---e
			- (stands for a time frame)
			a-z (are the values that are next’ed in the stream)
			| (indicates that the stream has completed)
			... (indicates that the stream will keep on living)
			# (indicates that an error occurred)
			^ (indicates where we start subscribing (only for hot streams)
			Perhaps it’s time to check a real example and how we might document it:

				const interval$ = interval(1000)            // 0--1--2--3--4--5--6...
				const new$ = interval$
					.pipe(
					        skip(1),                            // ---1--2--3--4--5--6...
					        take(5),                            // ---1--2--3--4--5|
					        filter(v => v % 2 === 0),           // ------2-----4-----6
					        map(v => v + 1)                     // ------3-----5-----7
				    )
		3. Using pure functions: A function is pure when:
			It doesn't mutate anything
			It will always return the same value based on the same parameters
			It doesn't have any side effects. It can't mutate state outside of the function.
		4. Avoiding memory leaks: To consume a stream we need to subscribe to that stream. When we subscribe to that stream a subscription will be created. That subscription will keep on living until the stream is completed or until we unsubscribe manually from that stream. Managing subscriptions is very important and in a number of cases we will have to manually unsubscribe an existing subscription to avoid memory leaks. Take this example for instance:

			class AppComponent implements OnInit {
			   ngOnInit() {
		        // The following stream will produce values every second
		        // 0--1--2--3--4--5--6--...
		        const interval$ = interval(1000);
		        // Even when this component gets destroyed,
			    // the stream will keep producing values...
				// This means the console will keep on logging
		        // This is a classic example of a memory-leak
		        const subscription = interval$.subscribe(r => console.log(r));
				}
			}
		To remove the memory-leak in this component we can keep track of the subscriptions by taking advantage of the ngOnDestroy() lifecycle hook of Angular:

			class AppComponent implements OnInit, OnDestroy {
				subscriptions = [];
				ngOnInit() {
				const interval$ = interval(1000);
				const subscription = interval$.subscribe(r => console.log(r));
				// manually keep track of the subscriptions in a subscription array
				this.subscriptions.push(subscription);
				 }

			    ngOnDestroy() {
		        // when the component get's destroyed, unsubscribe all the subscriptions
		        this.subscriptions.forEach(sub => sub.unsubscribe());
			  }
			}
		However, when we are using a bunch of subscriptions, it can become quite dirty. Before, we talked about the fact that a subscription will live until we manually unsubscribe (like we just did in the snippet above), but also until the stream gets completed. A cool way to handle this issue is to use a Subject that we next in the ngOnDestroy() lifecycle hook of Angular:

			class AppComponent implements OnInit, OnDestroy {
				destroy$ = new Subject();
				ngOnInit() {
				// interval$: 0--1--2--3--4--5--6--...
				// destroy$:  -------------true|
				// result:    0--1--2--3--4|
				const interval$ = interval(1000);
				interval$
				// let the interval$ stream live
				// until the destroy$ Subject gets a value
				.pipe(takeUntil(this.destroy$))
				.subscribe(r => console.log(r));
			    }

			    ngOnDestroy() {
				// when the component get's destroyed, pass something to the
				// destroy$ Subject
				this.destroy$.next(true);
				 }
			}

		5. Avoiding nested subscribes: Nesting subscribes is something that needs to be avoided as much as possible. It makes the code unreadable, complex, and introduces side effects. It basically forces you to NOT think reactively. Take this Angular example for instance:

			class AppComponent {
			    user: User;
				constructor(
					private route: ActivatedRoute,
					private userService: UserService)
				{
					// when the params of the route changes,
					// we want to fetch the user and set the user property
					//
					// VERY BAD: nesting subscribes is ugly and takes away
					// the control over a stream
					this.route.params
						.pipe(map(v => v.id))
						.subscribe(id =>
							this.userService.fetchById(id)
								.subscribe(user => this.user = user))
				}
			}
			The previous implementation is considered a bad-practice. It’s recommended to use higher-order streams like mergeMap or switchMap. Let’s have a look at this example:

			class AppComponent {
				user: User;
				constructor(
					private route: ActivatedRoute,
					private userService: UserService)
				{
					// when the params of the route changes,
					// we want to fetch the user and set the user property
					//
					// GOOD: we have created a single subscribe which makes
					// the flow way easier and gives us the control we need
					this.route.params
						.pipe(
							map(v => v.id),
							switchMap(id => this.userService.fetchById(id))
						 )
						.subscribe(user => this.user = user)
				}
			}
		6. Avoiding manual subscribes in Angular: To consume a stream we need to subscribe that stream, that's simply how observables work.
		But what if a component needs values from 5 different streams… Would that mean, that we want to subscribe to all of these streams a
		nd manually map all the values to unique properties, just to make it work? That would suck, right?!

			Angular has this super cool feature called the async pipe. It’s used to consume streams directly in the template The async pipe does 3 things for us:

				It subscribes to the stream and passes the value to a component
				It unsubscribes automatically when the component gets destroyed (removes a lot of unsubscribe logic)
				Triggers change detection automatically
			This means we don't have to manually subscribe nor unsubscribe anymore. Which cleans up the code a lot. Let’s have a look at the cleaned up previous example:

			@Component({
				...
				template: `
					<user-detail [user]="user$|async"></user-detail>
				`
			})
			class AppComponent {
				// expose a user$ stream that will be
				// subscribed in the template with the async pipe
				user$ = this.route.params.pipe(
					map(v => v.id),
					switchMap(id => this.userService.fetchById(id))
				);

				constructor(
					private route: ActivatedRoute,
					private userService: UserService) {
				}
			}
		7. Don't pass streams to components directly: One of the most important aspects of software architecture might be the concept of decoupling pieces of code. Therefore we could consider passing streams to child components as a bad practice because it creates a very tight link between the parent component and the child component. They are no longer decoupled since subscriptions in the child component might trigger actions in the parent component. We never want the child component to be responsible of initiating data calls right?! That's the task of the smart component. See the difference between smart and dumb components here. A component should always receive an object or value and should not even care if that object or value comes from a stream or not.
		// BAD
		// app.component.ts
		@Component({
		selector: 'app',
		template: `
			<!--
				BAD: The users$ steram is passed
				to user-detail directly as a stream
			-->
			<user-detail [user$]="user$"></user-detail>
		`
		})
		class AppComponent {
			// this http call will get called when the
			//user-detail component subscribes to users$
			// We don't want that
			users$ = this.http.get(...);
			...
		}

		// user-detail.component.ts
		@Component({
			selector: 'user-detail',
			template: `

			`
		})
		class UserDetailComponent implements OnInit {
			@Input() user$: Observable<User>;
			user: User;
			 ngOnInit(){
				// WHOOPS! This child component subscribes to the stream
				// of the parent component which will do an automatic XHR call
				// because Angular HTTP returns a cold stream
				this.user$.subscribe(u => this.user = u);
			}
		}
		It would be better to handle the subscription in the parent component itself:

		// GOOD
		//app.component.ts
		@Component({
			selector: 'app',
			template: `
				<user-detail [user]="user$|async"></user-detail>
			`
		})
		class AppComponent implements OnInit {
			users$: Observable<User[]> = this.http.get(...);
			user: User;
			ngOnInit(){
				// the app component (smart) subscribes to the user$ which will
				// do an XHR call here
				this.users$ = this.http.get(...);
			}
			...
		}

		// user-detail.component.ts
		@Component({
			selector: 'user-detail',
			template: `

			`
		})
		class UserDetailComponent {
			// This component doesn't even know that we are using RxJS which
			// results in better decoupling
			@Input() user: User;
		}
			The responsibility of the component is clear. The user-detail is meant to be dumb and is completely decoupled from its parent.
		There are however situations where we would like to create a stream from an input. In that case we could take a look at this library: ngx-reactivetoolkit
		8. Don't pass streams to services: Although, it might seem like a pragmatic solution to pass streams directly to services, it could be seen as a bad practice if we consider the decoupling again. By passing a stream to a service we don't know what's going to happen to it. The stream could be subscribed to, or even combined with another stream that has a longer life cycle, that could eventually determine the state of our application. Subscriptions might trigger unwanted behaviour. And after all, services don't care that your components are using streams. Take this example for instance:
		/ BAD
		// app.component.ts
		class AppComponent {
			 users$ = this.http.get(...)
			 filteredusers$ = this.fooService
		    .filterUsers(this.users$); // Passing stream directly: BAD
			...
		}

		// foo.service.ts
		class FooService {
		// return a stream based on a stream
		// BAD! because we don't know what will happen here
			filterUsers(users$: Observable<User[]>): Observable<User[]> {
				return users$.pipe(
		            map(users => users.filter(user => user.age >= 18))
			}
		}
		It would be better to use higher order streams for these situations. Use switchMap over mergeMap if possible, since it will unsubscribe the previous stream. The following example is better since all the RxJS logic is centralized in one place where the subscribing and unsubscribing happens: The smart component.

		// GOOD
		// app.component.ts
		class AppComponent {
			users$ = this.http.get(...)
			filteredusers$ = this.users$
				.pipe(switchMap(users => this.fooService.filterUsers(users)));
				...
				}

		// foo.service.ts
		class FooService {
			// this is way cleaner: this service doesn't even know
			// about streams now
			filterUsers(users: User[]): User[] {
				return users.filter(user => user.age >= 18);
			}
		}
		9. Since most streams are cold by default, every subscription will trigger the producer of these streams. The execution of the producer logic on every subscription, might not be what we want if we have multiple subscriptions. Eg. Subscribing to Angular its http.get() multiple times will actually perform multiple xhr calls. The following example will trigger the xhr call twice because numberOfUsers$ depends on users$.

		@Component({
			selector: 'app',
			template: `
				Number of users: {{numberOfUsers$|async}}
				<users-grid [users]="users$|async"></users-grid>
			`
		})
		// BAD
		class AppComponent {
			users$ = this.http.get(...)
			// the subscription on this stream will execute the xhr call again
			numberOfUsers$ = this.users$.pipe(map(v => v.length);
		}
		In those cases we might want to share the subscriptions. The following example uses the share() operator:

			@Component({
				selector: 'app',
				template: `
					Number of users: {{numberOfUsers$|async}}
					<users-grid [users]="users$|async"></users-grid>
				`
			})
			// GOOD
			class AppComponent {
				users$ = this.http.get(...).pipe(share());
				// the subscription on this stream will execute the xhr call again
				numberOfUsers$ = this.users$.pipe(map(v => v.length);
			}
		Sharing a stream makes it hot. This means that if we subscribe after the value is produced, we will miss that value. In that case we might want to use shareReplay(1) instead of share(). This will keep the last value in memory for us.

		It's a common mistake to share everything. We don’t always want to work with hot streams and sharing subscriptions comes with a small performance cost.Also, lazy streams have their advantages.

		Angular also provides a great alternative that can reduce the sharing of streams to a minimum by using the async as else syntax.. Personally I would consider the use of this feature as a best practice. The following example reduces the number of streams, the number of subscriptions and gives us an easy way to show a loading indicator.

		@Component({
			selector: 'app',
			template: `
				<div *ngIf="users$|async as users; else loading">
					Number of users:
					<users-grid [users]="users"></users-grid>
				</div>
				<ng-template #loading>Loading...</ng-template>
			`
		})
		class AppComponent {
			// This stream will only subscribed to once
		users$ = this.http.get(...);
		}
		8. When to use Subjects: A Subject is both a hot observable and an observer at the same time. This gives us the opportunity to next values into the stream ourselves. Subjects tend to be overused by people that didn't make the mind switch towards reactive programming yet. Only use them when really needed, for instance it's OK to use Subjects in the following scenarios:

			When mocking streams in tests
				const fetchAll$ = new Subject(); // use a Subject as a mock
				usersServiceMock.fetchAll.mockReturnValue(fetchAll$);
				fetchAll$.next(fakeUser);
			When we want to create streams from outputs in Angular
				@Component({
					...
					template: `
					<some-component (search)="search$.next($event)"></some-component>
					`
				})
				class AppComponent {
					search$ = new Subject(); // ----t-----te-----ter----term...
				}
			When handling circular references
			I'm not going to dive in this to deep, but Dominic Elm does an awesome job explaining this in this great article

		For most other cases an operator or Observable.create might be enough.

		Note: A BehaviorSubject is commonly used because it has a getValue() function. That would also be considered a bad practice. When we are trying to fetch a specific value it usually means we are not thinking reactive.
		10. Clean code practices:
			Align operators below each other
			Extract into different streams when it becomes unreadable
			Put complexer functionality in private methods (make the reactive flow clear)
			Avoid the use of brackets for readability, that's personal preference.






