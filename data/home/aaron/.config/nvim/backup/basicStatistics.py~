from math import sqrt
from random import randint
import linearAlgebra as lg
from collections import Counter
from matplotlib import pyplot as plt
from typing import List, Any
import sys
import os
sys.path.append(os.path.abspath("/home/projects/python/"))

"""
 mean= sum of data / count
 mode= Data with highest frequency
 median= middle most value, if the no. of data points is odd or avg. of the
 two middle-most values (if no. of data points is odd
 """

num_friends = [100, 249, 241, 25, 100, 200, 250, 300, 320, 220, 120, 190, 1000,
               333, 233, 133, 226, 123, 234, 345, 432, 321, 210, 102, 144, 322,
               245, 256, 432, 323, 423, 400, 333, 499, 399, 299, 199, 123, 234,
               456, 254, 432, 243, 132, 354, 323, 434, 453, 122, 322, 433, 123,
               143, 132, 111, 222, 333, 444, 100, 200, 300, 400, 225, 226, 227,
               228, 229, 210, 134, 145, 234, 434, 111, 389, 299, 276, 190, 165,
               211, 212, 213, 220, 230, 240, 100, 100, 280, 290, 295, 285, 257,
               387, 350, 122, 388, 299, 111, 223, 334, 400, 112, 221, 332, 443,
               195, 400, 129, 139, 137, 146, 134, 445, 134]  # type:List[int]
friend_counts = Counter(num_friends)
# print(friend_counts)
xs = range(1000)
ys = [friend_counts[x] for x in xs]
# plt.bar(xs, ys)
# plt.axis([0, 1100, 0, 6])
# # plt.title("Historgram of friends count")
# plt.xlabel("# of friends")
# plt.ylabel("# of people")
# plt.show()
num_points = len(num_friends)
largest_value = max(num_friends)
smallest_value = min(num_friends)
sorted_values = sorted(num_friends)

# print(sorted_values)


def mean(x: List[int])->float:
    return sum(x)/len(x)


mean__ = mean(num_friends)
print("mean", mean__)


def median(v: List[int])->float:
    """finds the middle most value of v"""
    n = len(v)
    sorted_v = sorted(v)
    midpoint = n // 2
    if n % 2 == 1:
        # if odd, return the middle value
        return sorted_v[midpoint]
    else:
        # if even, return average of the middle values
        lo = midpoint-1
        hi = midpoint
        return (sorted_v[lo]+sorted_v[hi])/2


median__ = median(num_friends)
print("median:", median__)


def quantile(x: List[int], p: float)->int:
    """returns the pth-percentile value in x"""
    p_index = int(p*len(x))
    # print("list length", len(x))
    # print("p_index", p_index)
    return sorted(x)[p_index]


print("QUANTILES example: A Quartile")
print("__________")

q10 = quantile(num_friends, .10)
q25 = quantile(num_friends, .25)
q75 = quantile(num_friends, .75)
q90 = quantile(num_friends, .90)
print("10 percentile:", q10)
print("25 percentile:", q25)
print("75 percentile:", q75)
print("90 percentile:", q90)


def mode(x: List[int])->List[int]:
    """returns a list,might be more than one mode"""
    counts = Counter(x)
    # print("Counts", counts.items())
    max_count = max(counts.values())
    return [x_i for x_i, count in counts.items()
            if count == max_count]


mode__ = mode(num_friends)
print("Mode", mode__)

""" Dispersion refers to how spread out the data is. Range is an example. Range
is the difference between the largest and smallest values"""


def data_range(x: List[int])->int:
    return max(x)-min(x)


data_range__ = data_range(num_friends)
print("range", data_range__)

"""Another example of dispersion is variance. Find the mean and substract from
individual value and then sum it and square it and divide by (n-1)
sigma(1->n)(x-xbar)Sq/(n-1)
"""


def de_mean(x: List[int])->List[Any]:
    """translate x by substracting its mean (so the result has mean 0)"""
    x_bar = mean(x)
    return [x_i - x_bar for x_i in x]


def variance(x: List[int])->float:
    """assumes x has atleast 2 elements"""
    n = len(x)
    deviations = de_mean(x)  # type: List[float]
    # print("deviations", deviations)
    return lg.sum_of_squares(deviations)/(n-1)


print("Variance", variance(num_friends))


def standard_deviation(x: List[int])->float:
    return sqrt(variance(x))


print("standard deviation", standard_deviation(num_friends))


def interquartile_range(x: List[int])->int:
    return quantile(x, 0.75)-quantile(x, 0.25)


print("interQuartile Range", interquartile_range(num_friends))


def covariance(x: List[Any], y: List[Any])->Any:
    n = len(x)
    return lg.dot(de_mean(x), de_mean(y))/n-1


time_spend = list(map(lambda x: x/randint(1, 4), num_friends))
print("covariance:", covariance(num_friends, time_spend))


def correlation(x: List[Any], y: List[Any])->float:
    stdev_x = standard_deviation(x)
    stdev_y = standard_deviation(y)
    if stdev_x > 0 and stdev_y > 0:
        return covariance(num_friends, time_spend) / stdev_x/stdev_y
    else:
        return 0


print("correlation", correlation(num_friends, time_spend))


# plt.scatter(num_friends, time_spend)
# plt.title("correlation with an outlier")
# plt.xlabel("# of friends")
# plt.ylabel("minutes per day")
# plt.show()
outlier_high = num_friends.index(1000)
outlier_low = num_friends.index(100)

num_friends_good = [x for i, x in enumerate(num_friends) if i != outlier_high
                    and i != outlier_low]
daily_minutes_good = [x for i, x in enumerate(time_spend)
                      if i != outlier_high and i != outlier_low]

print("better correlation", correlation(num_friends_good, daily_minutes_good))

plt.scatter(num_friends_good, daily_minutes_good)
plt.title("correlation with an outlier")
plt.xlabel("# of friends")
plt.ylabel("minutes per day")
plt.show()
